// src/services/UserDataService.ts
// --- DATA SERVICE MODULE ---
import { writable, get } from "svelte/store";

// Import Request Functions (adjust paths as necessary)
import store from "../../../../../../store.ts";
import type { NewsletterUser } from "../../../../../../types.ts";
import { addNewsletterUser } from "../../../../../requests/addNewsletterUserEndpoint.ts";
import subscribeNewsletterUser from "../../../../../requests/subscribeNewsletterUser.ts";
import getAllSubscribersFromConfigEndpoint from "../../../../../requests/getAllSubscribersFromConfigEndpoint.ts";
import unsubscribeUserToConfigNewsSource from "../../../../../requests/unsubscribeUserToConfigNewsSource.ts";
import getLeadsForConfigurator from "../../../../../requests/getLeadsForConfigurator.ts";
import getUsersFromRawFileOrText from "../../../../../requests/getUsersFromRawFileOrText.ts";

// --- Core State Stores ---
// Holds subscribers keyed by news source ID
export const subscribersByNewsSource = writable<
  Record<string, NewsletterUser[]>
>({});
// Holds lead data, potentially keyed by config ID -> news source ID -> user ID -> lead info
export const allLeadData = writable<
  Record<string, Record<string, Record<string, string>>>
>({});
// Loading state specifically for subscribers
export const loadingSubscribers = writable(true);
// Loading state specifically for leads
export const loadingLeads = writable(true);
// General error state, primarily for loading issues
export const loadingError = writable<string | null>(null);

// --- Helper Function ---
/**
 * Safely retrieves the configuratorEmail (configId) from the central store.
 * @returns {string | null} The configId or null if not found.
 */
function getConfigId(): string | null {
  const configStore = get(store);
  // Add checks for store and config object existence for robustness
  return configStore?.configuratorEmail ?? null;
}

// --- Service Functions ---

/**
 * Loads initial subscriber and lead data for the current configuration ID.
 * Updates the corresponding stores.
 */
export async function loadInitialData(): Promise<void> {
  const configId = getConfigId();
  if (!configId) {
    loadingError.set("Configuration ID (Email) not found in store.");
    loadingSubscribers.set(false);
    loadingLeads.set(false);
    return;
  }

  // Reset states before fetching
  loadingSubscribers.set(true);
  loadingLeads.set(true);
  loadingError.set(null);
  subscribersByNewsSource.set({}); // Clear potentially stale data
  allLeadData.set({}); // Clear potentially stale data

  try {
    // Fetch subscribers and leads concurrently
    const [subsResponse, leadsResponse] = await Promise.all([
      getAllSubscribersFromConfigEndpoint(configId),
      getLeadsForConfigurator(), // Assuming this fetches leads relevant to the user/config context
    ]);

    subscribersByNewsSource.set(subsResponse || {});

    // Assuming leadsResponse has a structure like { configId: { /* lead data */ } }
    // Adjust this based on the actual structure of leadsResponse
    allLeadData.set(leadsResponse?.[configId] || {});
  } catch (err: any) {
    console.error("Error fetching user/lead data in UserDataService:", err);
    loadingError.set(err.message || "Failed to load initial user data.");
    // Ensure stores are reset to empty on error to avoid showing stale data
    subscribersByNewsSource.set({});
    allLeadData.set({});
  } finally {
    // Ensure loading states are always set to false after attempt
    loadingSubscribers.set(false);
    loadingLeads.set(false);
  }
}

/**
 * Adds a newsletter user globally and then subscribes them to a specific news source.
 * Refreshes the subscriber list for all sources on success.
 * Throws an error if validation fails or API calls fail.
 *
 * @param userData - The basic data for the new user (name, email, lang, country, bio).
 * @param newsSourceId - The ID of the news source to subscribe the user to.
 */
export async function addUserAndSubscribe(
  userData: Pick<
    NewsletterUser,
    "name" | "email" | "bio" | "language" | "countryOfResidence"
  >,
  newsSourceId: string
): Promise<void> {
  // Returns void on success, throws on error
  const configId = getConfigId();
  if (!configId) {
    throw new Error("Action failed: Configuration ID missing.");
  }

  // --- Input Validation ---
  if (
    !userData.email ||
    !userData.name ||
    !userData.language ||
    !userData.countryOfResidence
  ) {
    throw new Error("Name, Email, Language, and Country are required.");
  }
  // Potentially add email format validation here if needed

  // Construct the full user object expected by addNewsletterUser
  // Assuming 'newsSourcesConfigTuples' is managed server-side or not needed for initial add
  const newUserForApi: NewsletterUser = {
    ...userData,
    id: "", // Usually generated by backend
    created_at: "", // Usually generated by backend
    updated_at: "", // Usually generated by backend
    newsSourcesConfigTuples: [], // Start with empty or let backend handle
  };

  try {
    // 1. Add the user (backend should handle if user already exists)
    await addNewsletterUser(newUserForApi, configId, newsSourceId);

    // 2. Subscribe the user to the specific news source
    // await subscribeNewsletterUser(configId, newsSourceId, userData.email);

    // 3. Refresh the subscriber list to ensure UI consistency
    // This is the simplest way to guarantee the store reflects the backend state.
    const subsResponse = await getAllSubscribersFromConfigEndpoint(configId);
    subscribersByNewsSource.set(subsResponse || {});
  } catch (err: any) {
    console.error(
      `Error adding/subscribing user ${userData.email} to ${newsSourceId}:`,
      err
    );
    // Re-throw the error with a potentially more user-friendly message
    // The calling component should catch this and display it appropriately.
    throw new Error(
      err.message || `Failed to add or subscribe user ${userData.email}.`
    );
  }
}

/**
 * Processes a file containing users, adds/updates them, and subscribes them to a specific news source.
 * Refreshes the subscriber list upon completion.
 *
 * @param file - The file object (.csv, .txt, .xlsx) containing user data.
 * @param newsSourceId - The ID of the news source to subscribe users to.
 * @returns {Promise<{ successMessage: string; errorMessage: string | null }>} - An object containing summary messages.
 * @throws {Error} - Throws an error for major issues like missing config ID or file processing failure.
 */
export async function processBulkUpload(
  file: File,
  newsSourceId: string
): Promise<{ successMessage: string; errorMessage: string | null }> {
  const configId = getConfigId();
  if (!configId) {
    throw new Error("Bulk upload failed: Configuration ID missing.");
  }

  let addedCount = 0;
  let subscribedCount = 0;
  const errors: string[] = [];
  let totalInFile = 0;

  try {
    // 1. Parse the file using the backend endpoint
    const usersFromFile = await getUsersFromRawFileOrText({ file });

    if (!usersFromFile || !Array.isArray(usersFromFile)) {
      // Handle cases where the backend might return null or non-array
      throw new Error(
        "Backend did not return a valid user list from the file."
      );
    }
    totalInFile = usersFromFile.length;

    // 2. Process each user from the file
    // Using Promise.allSettled allows all operations to attempt even if some fail.
    const results = await Promise.allSettled(
      usersFromFile.map(async (userFromFile) => {
        if (!userFromFile.email) {
          throw new Error(
            `Skipped user with missing email: ${
              userFromFile.name || "Unknown Name"
            }`
          );
        }

        // Prepare user data, using defaults from file or general defaults
        const userToAdd: NewsletterUser = {
          id: "", // Backend handles ID
          created_at: "",
          updated_at: "",
          name: userFromFile.name || "Unknown Name",
          email: userFromFile.email,
          bio: userFromFile.bio || "",
          language: userFromFile.language || "en", // Default language
          countryOfResidence: userFromFile.countryOfResidence || "US", // Default country
          newsSourcesConfigTuples: userFromFile.newsSourcesConfigTuples || [],
          // Include any other fields returned by getUsersFromRawFileOrText
          ...userFromFile,
        };

        let userAdded = false;
        let userSubscribed = false;

        // Attempt to add/update the user
        try {
          await addNewsletterUser(userToAdd, configId, newsSourceId);
          userAdded = true; // Count success
        } catch (addError: any) {
          // If error is "already exists", we still proceed to subscribe attempt.
          if (!addError?.message?.includes("already exists")) {
            throw new Error(
              `Error adding ${userFromFile.email}: ${addError.message}`
            ); // Propagate other add errors
          }
          // User exists, mark as 'added' for counting purposes (added/updated)
          userAdded = true;
        }

        // Attempt to subscribe the user
        try {
          await subscribeNewsletterUser(
            configId,
            newsSourceId,
            userFromFile.email
          );
          userSubscribed = true; // Count success
        } catch (subscribeError: any) {
          // If error is "already subscribed", it's still a success for this operation's goal.
          if (subscribeError?.message?.includes("already subscribed")) {
            userSubscribed = true; // Count if already subscribed
          } else {
            // If add succeeded but subscribe failed for other reasons
            throw new Error(
              `Error subscribing ${userFromFile.email}: ${subscribeError.message}`
            );
          }
        }
        return { added: userAdded, subscribed: userSubscribed };
      }) // End map
    ); // End Promise.allSettled

    // 3. Tally results and collect errors
    results.forEach((result, index) => {
      const userEmail = usersFromFile[index]?.email || `User at index ${index}`;
      if (result.status === "fulfilled") {
        if (result.value.added) addedCount++;
        if (result.value.subscribed) subscribedCount++;
      } else {
        // Log and collect errors from rejected promises
        errors.push(
          `${userEmail}: ${
            result.reason?.message || "Unknown processing error"
          }`
        );
        console.error(`Bulk processing error for ${userEmail}:`, result.reason);
      }
    });

    // 4. Refresh the subscriber list *after* all processing is done
    const subsResponse = await getAllSubscribersFromConfigEndpoint(configId);
    subscribersByNewsSource.set(subsResponse || {});

    // 5. Compile summary messages
    const successMessage = `Processed ${totalInFile} users from file. Added/Updated: ${addedCount}. Subscribed to this source: ${subscribedCount}.`;
    let errorMessage = null;
    if (errors.length > 0) {
      errorMessage = `Encountered ${
        errors.length
      } errors during processing: ${errors.slice(0, 3).join("; ")}${
        errors.length > 3 ? "..." : ""
      }. Check console for details.`;
      console.warn("Full bulk upload errors:", errors);
    }

    return { successMessage, errorMessage };
  } catch (err: any) {
    // Catch errors from getUsersFromRawFileOrText or other major issues
    console.error("Error during bulk add process:", err);
    throw new Error(err.message || "Failed to process bulk upload file.");
  }
}

/**
 * Unsubscribes a user from a specific news source.
 * Updates the local subscriber store on success.
 * Throws an error if the API call fails unexpectedly.
 *
 * @param userEmail - The email of the user to unsubscribe.
 * @param newsSourceId - The ID of the news source to unsubscribe from.
 * @returns {Promise<boolean>} - True if successfully unsubscribed (or already not subscribed), false if API indicates failure.
 * @throws {Error} - For unexpected errors during the API call.
 */
export async function unsubscribeUserFromSource(
  userEmail: string,
  newsSourceId: string
): Promise<boolean> {
  const configId = getConfigId();
  if (!configId) {
    // Log error but maybe don't throw, let UI handle disabled state?
    console.error("unsubscribeUserFromSource: Config ID not found.");
    // Or throw: throw new Error("Action failed: Configuration ID missing.");
    return false; // Indicate failure due to missing config
  }

  try {
    const success = await unsubscribeUserToConfigNewsSource(
      userEmail,
      configId,
      newsSourceId
    );

    if (success) {
      // Update the store locally for immediate UI feedback
      subscribersByNewsSource.update((current) => {
        const list = current[newsSourceId] || [];
        const updatedList = list.filter((u) => u.email !== userEmail);
        // Only update if the list actually changed
        if (updatedList.length !== list.length) {
          const newState = { ...current }; // Create new object for reactivity
          newState[newsSourceId] = updatedList;
          return newState;
        }
        return current; // Return same object if no change
      });
      console.log(
        `${userEmail} unsubscribed successfully from ${newsSourceId}.`
      );
      return true;
    } else {
      // API call completed but indicated failure (e.g., user not found, already unsubscribed)
      // In this case, we can treat it as 'job done' from the user's perspective.
      // We might want to refresh the store here to ensure consistency if the local state was wrong.
      console.warn(
        `API indicated no action needed for unsubscribing ${userEmail} from ${newsSourceId}. Refreshing list.`
      );
      const subsResponse = await getAllSubscribersFromConfigEndpoint(configId);
      subscribersByNewsSource.set(subsResponse || {});
      return true; // Still return true as the desired state (unsubscribed) is achieved or already existed.
    }
  } catch (err: any) {
    console.error(
      `Error removing user ${userEmail} from ${newsSourceId}:`,
      err
    );
    // Re-throw unexpected errors for the UI to handle
    throw new Error(err.message || `Failed to unsubscribe ${userEmail}.`);
  }
}
